"use strict";(globalThis.webpackChunkmy_website=globalThis.webpackChunkmy_website||[]).push([[7100],{650:(e,s,i)=>{i.r(s),i.d(s,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>t,metadata:()=>n,toc:()=>c});const n=JSON.parse('{"id":"ros2/index","title":"ROS 2 for Robot Control","description":"This module focuses on mastering the Robot Operating System 2 (ROS 2) for developing robust and scalable robotic applications. ROS 2 is a flexible framework for writing robot software, offering a collection of tools, libraries, and conventions that simplify the complex task of building robots. It enables developers to create modular and distributed systems, crucial for the advanced physical AI systems we aim to build.","source":"@site/docs/ros2/index.md","sourceDirName":"ros2","slug":"/ros2/","permalink":"/humanoid-robotics/ur/docs/ros2/","draft":false,"unlisted":false,"editUrl":"https://github.com/github/my-hackathone-project/tree/main/my-website/docs/ros2/index.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Exercise 2.1: Simple ROS 2 Publisher and Subscriber with Custom Message","permalink":"/humanoid-robotics/ur/docs/ros2/exercises/exercise1"},"next":{"title":"Lab 2.1: Basic Robot Control in Simulation","permalink":"/humanoid-robotics/ur/docs/ros2/labs/lab1"}}');var r=i(4848),o=i(8453);const t={},a="ROS 2 for Robot Control",l={},c=[{value:"What is ROS 2?",id:"what-is-ros-2",level:2},{value:"Key Features and Advantages of ROS 2 over ROS 1:",id:"key-features-and-advantages-of-ros-2-over-ros-1",level:3},{value:"Core Concepts of ROS 2",id:"core-concepts-of-ros-2",level:2},{value:"1. Nodes",id:"1-nodes",level:3},{value:"2. Topics",id:"2-topics",level:3},{value:"3. Messages",id:"3-messages",level:3},{value:"4. Services",id:"4-services",level:3},{value:"5. Actions",id:"5-actions",level:3},{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Simple ROS 2 Publisher-Subscriber Example (Python)",id:"simple-ros-2-publisher-subscriber-example-python",level:2},{value:"Publisher (<code>talker.py</code>)",id:"publisher-talkerpy",level:3},{value:"Subscriber (<code>listener.py</code>)",id:"subscriber-listenerpy",level:3},{value:"Practical Exercises",id:"practical-exercises",level:2},{value:"Labs",id:"labs",level:2},{value:"Sections",id:"sections",level:2}];function d(e){const s={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(s.header,{children:(0,r.jsx)(s.h1,{id:"ros-2-for-robot-control",children:"ROS 2 for Robot Control"})}),"\n",(0,r.jsx)(s.p,{children:"This module focuses on mastering the Robot Operating System 2 (ROS 2) for developing robust and scalable robotic applications. ROS 2 is a flexible framework for writing robot software, offering a collection of tools, libraries, and conventions that simplify the complex task of building robots. It enables developers to create modular and distributed systems, crucial for the advanced physical AI systems we aim to build."}),"\n",(0,r.jsx)(s.h2,{id:"what-is-ros-2",children:"What is ROS 2?"}),"\n",(0,r.jsx)(s.p,{children:"ROS 2 is the successor to the original Robot Operating System (ROS 1), reimagined to address the demands of modern robotics, particularly in areas like real-time control, multi-robot systems, and embedded platforms. It provides a standardized communication infrastructure for different processes (nodes) to exchange data, facilitating the development of complex robotic behaviors by breaking them down into smaller, manageable components."}),"\n",(0,r.jsx)(s.h3,{id:"key-features-and-advantages-of-ros-2-over-ros-1",children:"Key Features and Advantages of ROS 2 over ROS 1:"}),"\n",(0,r.jsxs)(s.ol,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Quality of Service (QoS) Settings:"})," ROS 2 introduces flexible QoS policies (e.g., reliability, durability, history, deadline) that allow developers to fine-tune communication behavior based on application needs, critical for real-time and mission-critical systems."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Distributed Nature (DDS):"})," Built on the Data Distribution Service (DDS) standard, ROS 2 is inherently distributed, allowing seamless communication across multiple machines, networks, and even different operating systems without a central master node."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Support for Embedded Systems:"})," Designed with embedded systems and microcontrollers in mind, ROS 2 can run on a wider range of hardware, from powerful workstations to resource-constrained edge devices."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Security:"})," ROS 2 includes built-in security features (SROS 2) for authentication, authorization, and encryption, essential for deployments in sensitive environments."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Multi-Robot Support:"})," Its distributed architecture and improved discovery mechanisms make it ideal for coordinating multiple robots."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Real-Time Capabilities:"})," While not a hard real-time OS, ROS 2 provides mechanisms and best practices to improve determinism and predictability, crucial for control loops."]}),"\n"]}),"\n",(0,r.jsx)(s.h2,{id:"core-concepts-of-ros-2",children:"Core Concepts of ROS 2"}),"\n",(0,r.jsx)(s.p,{children:"Understanding these fundamental concepts is key to developing applications with ROS 2:"}),"\n",(0,r.jsx)(s.h3,{id:"1-nodes",children:"1. Nodes"}),"\n",(0,r.jsx)(s.p,{children:"Nodes are executable processes that perform computation. In a robotic system, different functionalities are typically encapsulated in separate nodes. For instance, one node might control a motor, another might process camera data, and a third might handle navigation logic."}),"\n",(0,r.jsx)(s.h3,{id:"2-topics",children:"2. Topics"}),"\n",(0,r.jsx)(s.p,{children:"Topics are named buses over which nodes exchange messages. A node can publish messages to a topic, and other nodes can subscribe to that topic to receive the messages. This is a one-to-many communication mechanism, ideal for streaming data."}),"\n",(0,r.jsx)(s.h3,{id:"3-messages",children:"3. Messages"}),"\n",(0,r.jsx)(s.p,{children:"Messages are data structures used for communication over topics. ROS 2 provides a rich set of standard message types for common data (e.g., sensor readings, robot commands, images), and users can define custom message types."}),"\n",(0,r.jsx)(s.h3,{id:"4-services",children:"4. Services"}),"\n",(0,r.jsx)(s.p,{children:"Services are a request/reply communication mechanism. A service server node offers a service, and a service client node sends a request to the server and waits for a response. This is a synchronous, one-to-one communication pattern, suitable for operations that return a result."}),"\n",(0,r.jsx)(s.h3,{id:"5-actions",children:"5. Actions"}),"\n",(0,r.jsx)(s.p,{children:'Actions are a long-running, asynchronous communication mechanism. An action client sends a goal to an action server, which then provides continuous feedback on its progress and a final result. This is ideal for tasks like "navigate to a point" or "pick up an object," where progress updates are valuable.'}),"\n",(0,r.jsx)(s.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsx)(s.li,{children:"Understand the fundamental architecture and design principles of ROS 2."}),"\n",(0,r.jsx)(s.li,{children:"Differentiate between ROS 1 and ROS 2, recognizing the advancements and motivations behind the latter."}),"\n",(0,r.jsx)(s.li,{children:"Master core ROS 2 communication concepts: Nodes, Topics, Messages, Services, and Actions."}),"\n",(0,r.jsx)(s.li,{children:"Develop and deploy basic ROS 2 packages using Python."}),"\n",(0,r.jsx)(s.li,{children:"Gain proficiency in controlling simulated robots through ROS 2 interfaces."}),"\n"]}),"\n",(0,r.jsx)(s.h2,{id:"simple-ros-2-publisher-subscriber-example-python",children:"Simple ROS 2 Publisher-Subscriber Example (Python)"}),"\n",(0,r.jsx)(s.p,{children:'Let\'s illustrate the concept of topics with a basic "talker-listener" example.'}),"\n",(0,r.jsxs)(s.h3,{id:"publisher-talkerpy",children:["Publisher (",(0,r.jsx)(s.code,{children:"talker.py"}),")"]}),"\n",(0,r.jsx)(s.p,{children:'This node will publish a simple "Hello ROS 2" message every second.'}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom std_msgs.msg import String\n\nclass MinimalPublisher(Node):\n    def __init__(self):\n        super().__init__('minimal_publisher')\n        self.publisher_ = self.create_publisher(String, 'topic', 10)\n        timer_period = 1.0  # seconds\n        self.timer = self.create_timer(timer_period, self.timer_callback)\n        self.i = 0\n\n    def timer_callback(self):\n        msg = String()\n        msg.data = 'Hello ROS 2: %d' % self.i\n        self.publisher_.publish(msg)\n        self.get_logger().info('Publishing: \"%s\"' % msg.data)\n        self.i += 1\n\ndef main(args=None):\n    rclpy.init(args=args)\n    minimal_publisher = MinimalPublisher()\n    rclpy.spin(minimal_publisher)\n    minimal_publisher.destroy_node()\n    rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,r.jsxs)(s.h3,{id:"subscriber-listenerpy",children:["Subscriber (",(0,r.jsx)(s.code,{children:"listener.py"}),")"]}),"\n",(0,r.jsx)(s.p,{children:"This node will subscribe to the 'topic' and print the received messages."}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom std_msgs.msg import String\n\nclass MinimalSubscriber(Node):\n    def __init__(self):\n        super().__init__('minimal_subscriber')\n        self.subscription = self.create_subscription(\n            String,\n            'topic',\n            self.listener_callback,\n            10)\n        self.subscription  # prevent unused variable warning\n\n    def listener_callback(self, msg):\n        self.get_logger().info('I heard: \"%s\"' % msg.data)\n\ndef main(args=None):\n    rclpy.init(args=args)\n    minimal_subscriber = MinimalSubscriber()\n    rclpy.spin(minimal_subscriber)\n    minimal_subscriber.destroy_node()\n    rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,r.jsx)(s.p,{children:"To run this example:"}),"\n",(0,r.jsxs)(s.ol,{children:["\n",(0,r.jsxs)(s.li,{children:["Save ",(0,r.jsx)(s.code,{children:"talker.py"})," and ",(0,r.jsx)(s.code,{children:"listener.py"})," in a new ROS 2 package."]}),"\n",(0,r.jsx)(s.li,{children:"Build the package."}),"\n",(0,r.jsxs)(s.li,{children:["Open two terminals. In the first, run ",(0,r.jsx)(s.code,{children:"ros2 run <your_package_name> talker"}),"."]}),"\n",(0,r.jsxs)(s.li,{children:["In the second, run ",(0,r.jsx)(s.code,{children:"ros2 run <your_package_name> listener"}),"."]}),"\n"]}),"\n",(0,r.jsx)(s.p,{children:"You should see the listener node receiving and printing the messages published by the talker."}),"\n",(0,r.jsx)(s.h2,{id:"practical-exercises",children:"Practical Exercises"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Exercise 2.1:"})," Create a simple ROS 2 publisher and subscriber using a custom message type."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Exercise 2.2:"})," Implement a ROS 2 service client and server, where the client sends two numbers and the server returns their sum."]}),"\n"]}),"\n",(0,r.jsx)(s.h2,{id:"labs",children:"Labs"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Lab 2.1:"})," Basic robot control in a simulated environment using ROS 2. This lab will involve sending ",(0,r.jsx)(s.code,{children:"Twist"})," messages to a simulated robot to control its linear and angular velocities, and monitoring its odometry data."]}),"\n"]}),"\n",(0,r.jsx)(s.h2,{id:"sections",children:"Sections"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.a,{href:"/humanoid-robotics/ur/docs/ros2/week1_overview",children:"Week 1 Overview"})," (Note: This is an introductory week for ROS 2)"]}),"\n",(0,r.jsx)(s.li,{children:(0,r.jsx)(s.a,{href:"/humanoid-robotics/ur/docs/ros2/exercises/exercise1",children:"Exercise 2.1 Solution"})}),"\n",(0,r.jsx)(s.li,{children:(0,r.jsx)(s.a,{href:"/humanoid-robotics/ur/docs/ros2/labs/lab1",children:"Lab 2.1 Guide"})}),"\n"]})]})}function h(e={}){const{wrapper:s}={...(0,o.R)(),...e.components};return s?(0,r.jsx)(s,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,s,i)=>{i.d(s,{R:()=>t,x:()=>a});var n=i(6540);const r={},o=n.createContext(r);function t(e){const s=n.useContext(o);return n.useMemo(function(){return"function"==typeof e?e(s):{...s,...e}},[s,e])}function a(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:t(e.components),n.createElement(o.Provider,{value:s},e.children)}}}]);